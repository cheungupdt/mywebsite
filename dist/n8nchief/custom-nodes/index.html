<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Custom Nodes - KCS Team</title>
    <meta name="description" content="Tailored solutions for unique requirements">
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="stylesheet" href="/assets/css/components.css">
    <link rel="stylesheet" href="/assets/css/diagram.css">
    <link rel="stylesheet" href="/assets/css/expertise.css"> 
    <link rel="alternate" type="application/rss+xml" title="KCS Team - RSS Feed" href="/feed.xml">
</head>
<body>
    <a href="#main" class="skip-link">Skip to main content</a>
    
    <header class="header">
        <div class="container">
            <div class="header-content">
                <a href="/" class="logo">KCS Team</a>
                <nav class="nav">
                    <a href="/" class="nav-link">Home</a>
                    <a href="/blog/" class="nav-link">Blog</a>
                    <a href="/projects/" class="nav-link">Projects</a>
                    <a href="/achievements/" class="nav-link">Achievements</a>
                    <a href="/speaking/" class="nav-link">Speaking</a>
                    <a href="/diagrams/" class="nav-link">Diagrams</a>
                    <a href="/robotics/" class="nav-link">Robotics</a>
                    <a href="/n8nchief/" class="nav-link">n8n Expertise</a>
                    <a href="/leadership/" class="nav-link">Leadership</a>
                    <a href="/innovation/" class="nav-link">Innovation</a>
                    <a href="/contact/" class="nav-link">Contact</a>
                    <a href="/rss/" class="nav-link rss-link" title="RSS Feed">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M4 11a9 9 0 0 1 9 9v1.5a1.5 1.5 0 0 1-3 0V20a7 7 0 0 0-7-7v-1.5a1.5 1.5 0 0 1 3 0V11Z" fill="currentColor"/>
                            <path d="M4 4.5A1.5 1.5 0 0 1 5.5 3v1.5a10.5 10.5 0 0 1 10.5 10.5v1.5a1.5 1.5 0 0 1-3 0V15A7.5 7.5 0 0 0 5.5 7.5V6A1.5 1.5 0 0 1 4 4.5Z" fill="currentColor"/>
                            <circle cx="6" cy="18" r="1.5" fill="currentColor"/>
                        </svg>
                    </a>
                </nav>
            </div>
        </div>
    </header>
    
    <main id="main" class="main">
        <div class="container">
            <h1>Custom Nodes</h1>
<h2>Overview</h2>
<p>While n8n provides an extensive library of nodes, sometimes business requirements demand specialized functionality. Custom nodes bridge these gaps, providing tailored solutions that perfectly fit unique workflows and integration needs.</p>
<h2>When to Build Custom Nodes</h2>
<h3>1. Proprietary Systems</h3>
<ul>
<li>Internal APIs without public documentation</li>
<li>Legacy systems with unique protocols</li>
<li>Custom data formats</li>
<li>Specialized authentication methods</li>
</ul>
<h3>2. Complex Business Logic</h3>
<ul>
<li>Multi-step data transformations</li>
<li>Industry-specific calculations</li>
<li>Complex validation rules</li>
<li>Custom error handling</li>
</ul>
<h3>3. Performance Requirements</h3>
<ul>
<li>High-volume data processing</li>
<li>Real-time processing needs</li>
<li>Memory optimization</li>
<li>Batch processing optimization</li>
</ul>
<h3>4. Integration Limitations</h3>
<ul>
<li>Missing features in existing nodes</li>
<li>Rate limiting workarounds</li>
<li>Enhanced error recovery</li>
<li>Advanced retry mechanisms</li>
</ul>
<h2>Custom Node Development Process</h2>
<h3>1. Requirements Analysis</h3>
<ul>
<li>Define node functionality</li>
<li>Identify input/output specifications</li>
<li>Document error scenarios</li>
<li>Plan testing strategy</li>
</ul>
<h3>2. Architecture Design</h3>
<pre><code class="language-javascript">// Node structure template
class CustomNode {
  constructor() {
    this.description = {
      displayName: 'Custom Processing Node',
      name: 'customProcessing',
      group: ['transform'],
      version: 1,
      description: 'Custom data processing logic',
      defaults: {
        name: 'Custom Processing',
        color: '#666666'
      },
      inputs: ['main'],
      outputs: ['main'],
      properties: {
        // Node properties definition
      }
    };
  }
  
  async execute() {
    // Node execution logic
  }
}
</code></pre>
<h3>3. Implementation</h3>
<ul>
<li>Core functionality development</li>
<li>Error handling implementation</li>
<li>Input validation</li>
<li>Output formatting</li>
</ul>
<h3>4. Testing &amp; Validation</h3>
<ul>
<li>Unit testing</li>
<li>Integration testing</li>
<li>Performance testing</li>
<li>Security testing</li>
</ul>
<h2>Custom Node Examples</h2>
<h3>1. Advanced Data Transformer</h3>
<pre><code class="language-javascript">// Complex data transformation node
class AdvancedTransformer {
  constructor() {
    this.description = {
      displayName: 'Advanced Data Transformer',
      name: 'advancedTransformer',
      // ... other properties
      properties: {
        transformationRules: {
          type: 'json',
          label: 'Transformation Rules',
          default: {}
        },
        errorHandling: {
          type: 'options',
          options: [
            { name: 'Skip', value: 'skip' },
            { name: 'Error', value: 'error' },
            { name: 'Default', value: 'default' }
          ]
        }
      }
    };
  }
  
  async execute() {
    const items = this.getInputData();
    const rules = this.getNodeParameter('transformationRules');
    const errorHandling = this.getNodeParameter('errorHandling');
    
    const transformedItems = [];
    
    for (let i = 0; i &lt; items.length; i++) {
      try {
        const transformed = this.applyRules(items[i].json, rules);
        transformedItems.push({ json: transformed });
      } catch (error) {
        if (errorHandling === 'error') {
          throw error;
        } else if (errorHandling === 'default') {
          transformedItems.push({ json: rules.defaultValue });
        }
        // Skip if errorHandling is 'skip'
      }
    }
    
    return this.prepareOutputData(transformedItems);
  }
  
  applyRules(data, rules) {
    // Complex transformation logic
    let result = { ...data };
    
    for (const [field, rule] of Object.entries(rules)) {
      switch (rule.type) {
        case 'map':
          result[field] = rule.mapping[result[field]] || result[field];
          break;
        case 'calculate':
          result[field] = this.calculate(result, rule.formula);
          break;
        case 'validate':
          if (!this.validate(result[field], rule.criteria)) {
            throw new Error(`Validation failed for ${field}`);
          }
          break;
        // ... more rule types
      }
    }
    
    return result;
  }
}
</code></pre>
<h3>2. Smart Retry Node</h3>
<pre><code class="language-javascript">// Intelligent retry mechanism
class SmartRetry {
  constructor() {
    this.description = {
      displayName: 'Smart Retry',
      name: 'smartRetry',
      // ... properties
      properties: {
        maxRetries: { type: 'number', default: 3 },
        backoffStrategy: {
          type: 'options',
          options: [
            { name: 'Linear', value: 'linear' },
            { name: 'Exponential', value: 'exponential' },
            { name: 'Fixed', value: 'fixed' }
          ]
        },
        baseDelay: { type: 'number', default: 1000 },
        retryConditions: {
          type: 'json',
          label: 'Retry Conditions',
          default: {
            statusCodes: [500, 502, 503, 504],
            errors: ['timeout', 'connection']
          }
        }
      }
    };
  }
  
  async execute() {
    const items = this.getInputData();
    const maxRetries = this.getNodeParameter('maxRetries');
    const strategy = this.getNodeParameter('backoffStrategy');
    const baseDelay = this.getNodeParameter('baseDelay');
    const conditions = this.getNodeParameter('retryConditions');
    
    const results = [];
    
    for (const item of items) {
      let lastError;
      let success = false;
      
      for (let attempt = 0; attempt &lt;= maxRetries; attempt++) {
        try {
          const result = await this.executeWithRetry(item.json);
          results.push({ json: result });
          success = true;
          break;
        } catch (error) {
          lastError = error;
          
          if (attempt &lt; maxRetries &amp;&amp; this.shouldRetry(error, conditions)) {
            const delay = this.calculateDelay(attempt, strategy, baseDelay);
            await this.sleep(delay);
          }
        }
      }
      
      if (!success) {
        throw lastError;
      }
    }
    
    return this.prepareOutputData(results);
  }
  
  shouldRetry(error, conditions) {
    // Check if error matches retry conditions
    if (conditions.statusCodes.includes(error.statusCode)) {
      return true;
    }
    
    if (conditions.errors.some(type =&gt; error.message.includes(type))) {
      return true;
    }
    
    return false;
  }
  
  calculateDelay(attempt, strategy, baseDelay) {
    switch (strategy) {
      case 'linear':
        return baseDelay * (attempt + 1);
      case 'exponential':
        return baseDelay * Math.pow(2, attempt);
      case 'fixed':
        return baseDelay;
      default:
        return baseDelay;
    }
  }
}
</code></pre>
<h3>3. Batch Processor Node</h3>
<pre><code class="language-javascript">// Efficient batch processing
class BatchProcessor {
  constructor() {
    this.description = {
      displayName: 'Batch Processor',
      name: 'batchProcessor',
      // ... properties
      properties: {
        batchSize: { type: 'number', default: 100 },
        processingMode: {
          type: 'options',
          options: [
            { name: 'Parallel', value: 'parallel' },
            { name: 'Sequential', value: 'sequential' }
          ]
        },
        concurrency: { type: 'number', default: 5 }
      }
    };
  }
  
  async execute() {
    const items = this.getInputData();
    const batchSize = this.getNodeParameter('batchSize');
    const mode = this.getNodeParameter('processingMode');
    const concurrency = this.getNodeParameter('concurrency');
    
    const batches = this.createBatches(items, batchSize);
    const results = [];
    
    if (mode === 'parallel') {
      const batchPromises = batches.map(batch =&gt; 
        this.processBatch(batch, concurrency)
      );
      const batchResults = await Promise.all(batchPromises);
      results.push(...batchResults.flat());
    } else {
      for (const batch of batches) {
        const batchResults = await this.processBatch(batch, 1);
        results.push(...batchResults);
      }
    }
    
    return this.prepareOutputData(results);
  }
  
  createBatches(items, size) {
    const batches = [];
    for (let i = 0; i &lt; items.length; i += size) {
      batches.push(items.slice(i, i + size));
    }
    return batches;
  }
  
  async processBatch(batch, concurrency) {
    // Process batch with specified concurrency
    const semaphore = new Semaphore(concurrency);
    
    const promises = batch.map(async (item) =&gt; {
      await semaphore.acquire();
      try {
        return await this.processItem(item);
      } finally {
        semaphore.release();
      }
    });
    
    return Promise.all(promises);
  }
}
</code></pre>
<h2>Best Practices</h2>
<h3>1. Code Organization</h3>
<ul>
<li>Modular design</li>
<li>Clear separation of concerns</li>
<li>Comprehensive documentation</li>
<li>Version control</li>
</ul>
<h3>2. Error Handling</h3>
<ul>
<li>Graceful degradation</li>
<li>Detailed error messages</li>
<li>Recovery mechanisms</li>
<li>Logging</li>
</ul>
<h3>3. Performance</h3>
<ul>
<li>Memory efficiency</li>
<li>CPU optimization</li>
<li>Network usage minimization</li>
<li>Caching strategies</li>
</ul>
<h3>4. Security</h3>
<ul>
<li>Input validation</li>
<li>Output sanitization</li>
<li>Secure credential handling</li>
<li>Audit logging</li>
</ul>
<h2>Deployment &amp; Distribution</h2>
<h3>Community Sharing</h3>
<ul>
<li>Publish to n8n community</li>
<li>Documentation and examples</li>
<li>Version management</li>
<li>Support and maintenance</li>
</ul>
<h3>Enterprise Distribution</h3>
<ul>
<li>Private npm registry</li>
<li>Internal documentation</li>
<li>Training materials</li>
<li>Support SLA</li>
</ul>
<h2>Case Study: Custom ERP Integration Node</h2>
<h3>Challenge</h3>
<p>Integrate with legacy ERP system using proprietary protocol and complex data structures</p>
<h3>Solution</h3>
<p>Developed custom node with:</p>
<ul>
<li>Proprietary protocol implementation</li>
<li>Complex data mapping</li>
<li>Real-time synchronization</li>
<li>Advanced error recovery</li>
</ul>
<h3>Results</h3>
<ul>
<li><strong>Integration Time</strong>: Reduced from weeks to hours</li>
<li><strong>Data Accuracy</strong>: 99.99%</li>
<li><strong>Processing Speed</strong>: 10x improvement</li>
<li><strong>Maintenance</strong>: 80% reduction</li>
</ul>

        </div>
    </main>
    
    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <p>&copy; undefined NaN, NaN KCS Team. All rights reserved.</p>
                <div class="footer-links">
                    <a href="/rss/" class="footer-link">RSS Feed</a>
                    
                    <a href="#" class="footer-link">LinkedIn</a>
                    
                    
                    <a href="#" class="footer-link">GitHub</a>
                    
                    
                    <a href="#" class="footer-link">Twitter</a>
                    
                </div>
            </div>
        </div>
    </footer>
    
    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="/assets/js/diagrams.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script src="/assets/js/lightbox.js"></script>
    <script src="/assets/js/navigation.js"></script>
</body>
</html>